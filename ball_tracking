# This work is licensed under the MIT license.
# Copyright (c) 2013-2023 OpenMV LLC. All rights reserved.
# https://github.com/openmv/openmv/blob/master/LICENSE
#
# Hello World Example
#
# Welcome to the OpenMV IDE! Click on the green run arrow button below to run the script!

# --------------------------------导入外部文件中的包和模块减↓↓↓----------------------------
import sensor, image,time,display    # 导入摄像头传感器，图像，显示器相关包
from pyb import UART,Pin,Timer
from pid import PID # 从pyb包中导入Pin模块
from LQ_Module import motor     # 从LQ_Module文件中导入motor
uart = UART(3, 115200)
# --------------------------------设置初始变量、参数↓↓↓--------------------------------------
red_threshold = [
    (15, 65, 37, 59, 11, 46)   #红色，请在实际使用场景中采集
]
green_threshold = [
    (0, 82, 60, -20, -18, 49)   #绿色，请在实际使用场景中采集
]
min_speed = 800    # 最小速度（电机的死区，低于这个值电机不会启动）
speed = 1200        # 基准速度（控制整体前进速度，小车运行时的基本速度）

speed_L = 0         # 左轮速度暂存全局变量（各电机的实际速度值：基准±偏差值）
speed_R = 0         # 右轮速度暂存全局变量
speed_B = 0         # 后轮速度暂存全局变量

#start_flag = False  # 电机转动标志位，通过K0按键切换，为True时电机转动，否则电机不转
#===============================各个外设初始化↓↓↓========================================

# ---------------------------TFT-LCD显示初始化↓↓↓--------------------------------------
lcd = display.SPIDisplay()          # 初始化显示屏（参数默认-空）
lcd.clear()                         # 清屏
pic=image.Image("/pic0.jpg")        # 读取图片
lcd.write(pic)                      # 显示图片

# -----------------------------初始化摄像头↓↓↓-------------------------------------
sensor.reset()                      # 初始化摄像头
sensor.set_hmirror(True)            # 镜像（如果视觉模块倒着安装，则开启这个镜像）
sensor.set_pixformat(sensor.RGB565) # 采集格式（彩色图像采集）
sensor.set_framesize(sensor.LCD)    # 设置图像大小 128*160
sensor.skip_frames(time = 2000)     # 跳过前两秒图像后，关闭自动增益白平衡
sensor.set_auto_gain(False)         # 必须关闭自动曝光才能进行相对稳定的颜色跟踪
sensor.set_auto_whitebal(False)     # 必须关闭自动白平衡才能进行相对稳定的颜色跟踪

# -----------------------------自定义函数↓↓↓-------------------------------------
## 在传入色块对象中找到面积最大的色块返回
#def find_max(blobs):
#    max_size=0
#    for blob in blobs:
#        if blob[2]*blob[3] > max_size:
#            max_blob=blob
#            max_size = blob[2]*blob[3]
#    return max_blob

# ================================= 程序主循环 ==========================================

while(True):
        img = sensor.snapshot()             # 获取一帧图像
        green_blobs = img.find_blobs(green_threshold,pixels_threshold=100, area_threshold=100, merge=True)

        red_blobs = img.find_blobs(red_threshold,pixels_threshold=100, area_threshold=100, merge=True)

        lcd.write(img)          # 显示屏显示图像

        if not red_blobs:
            speed_L = -900
            speed_R = -900
            speed_B = -900

        else:
            if (78<(red_blobs[0]).w()<=93):
                if green_blobs :
                    speed_L = 900
                    speed_R = -900
                    speed_B = 0

                else  :
                    speed_L = 0
                    speed_R = 0
                    speed_B = -900

            elif (red_blobs[0]).w() > 93 :
                if 0<(red_blobs[0]).cx()<=50:
                    speed_L = -800
                    speed_R = -800
                    speed_B = -800

                elif 250<(red_blobs[0]).cx()<=300:
                    speed_L = 800
                    speed_R = 800
                    speed_B = 800

                elif 50<(red_blobs[0]).cx()<=250:
                    if green_blobs:
                        if 30<abs((green_blobs[0]).cx()-(red_blobs[0]).cx())<=50:
                            speed_L = 800
                            speed_R = -800
                            speed_B = 0

                        elif abs((green_blobs[0]).cx()-(red_blobs[0]).cx())>50:
                            speed_L = 0
                            speed_R = 0
                            speed_B = -800
                        elif abs((green_blobs[0]).cx()-(red_blobs[0]).cx())<=30:

                            x_error = (red_blobs[0]).cx()-img.width()/2                       # 计算红色中心偏差x_error

                            x2_error = (green_blobs[0]).cx()-(red_blobs[0]).cx()

                            speed_L = -speed + x_error*5 - x2_error*5

                            speed_R = +speed + x_error*5 - x2_error*5
                            #error大 向右转
                            if x_error>8:
                                speed_B =-800
                            if x_error<-8:
                                speed_B =800
                            else:
                                speed_B = 0



#                    if green_blobs and 0<(green_blobs[0]).cx()<100 :
#                        if green_blobs.cx() > red_blobs.cx() :
#                            speed_L = 1100
#                            speed_R = -1100
#                            speed_B = 1100
#

#                        if (green_blobs[0]).cx() < (red_blobs[0]).cx() :
#                            speed_L = 1100
#                            speed_R = -1100
#                            speed_B = -1100
#


#                            blob = find_max(red_blobs)  # 提取blobs中面积最大的一个红色色块blob
#                            x_error = blob.cx()-img.width()/2                       # 计算红色中心偏差x_error

#                            speed_L = speed + x_error*35
#                            speed_R = -speed + x_error*35
#                            #error大 向右转
#                            if x_error>8:
#                               speed_B = 11000
#                            if x_error<-8:
#                                speed_B =-11000
#                            else:
#                               speed_B = 0

                        else:

                            speed_L = 1100
                            speed_R = -1100
                            speed_B = -1100
                else:
                    speed_L = 0
                    speed_R = -1100
                    speed_B = 1100

            elif (red_blobs[0]).w()<=78:
                if 0<(red_blobs[0]).cx()<200:
                    speed_L = 700
                    speed_R = 700
                    speed_B = 700

                elif 200<(red_blobs[0]).cx()<300:
                    speed_L = -700
                    speed_R = -700
                    speed_B = -700

                else:
                    speed_L = 1100
                    speed_R = -1100
                    speed_B = 0



















        print(speed_L,speed_R,speed_B) # 串行终端打印，偏差和最终电机输出值



        # 左轮
        left = 0
        right = 0
        back = 0

        # 放在 while() 里！
        data = [int(speed_L), int(speed_R), speed_B]

        uart.write(str(data) + '\n')
        time.sleep_ms(50)

